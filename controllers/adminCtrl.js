const User = require("../models/userModels");
const Admin = require("../models/adminModel");
const Employee = require("../models/employeeModel");
const Customer = require("../models/customerModel");
const productCategory = require("../models/productCategoryModels");
const Product = require("../models/productModels");
const Court = require("../models/courtModel");
const TimeSlot = require("../models/timeSlotModel");
const TimeSlotBooking = require("../models/timeSlotBookingModel");
const Booking = require("../models/bookingModel");
const bcrypt = require("bcryptjs");
const fs = require("fs");
const path = require("path");
const Invoice = require("../models/invoiceModel");
const InvoiceDetail = require("../models/invoiceDetailModel");
const moment = require("moment");
const dayjs = require("dayjs");
const mongoose = require("mongoose");

const getAllUsersController = async (req, res) => {
  try {
    const users = await User.find({});
    res.status(200).send({
      success: true,
      message: "users data list",
      data: users,
    });
  } catch (error) {
    console.log(error);
    res.status(500).send({
      success: false,
      message: "error while fetching users",
      error,
    });
  }
};

//Khung gi·ªù
const getAllTimeSlotController = async (req, res) => {
  try {
    const timeSlots = await TimeSlot.find().sort({ time: 1 }); // L·∫•y t·∫•t c·∫£ khung gi·ªù v√† s·∫Øp x·∫øp theo th·ªùi gian
    res.status(200).json({
      success: true,
      message: "L·∫•y danh s√°ch khung gi·ªù th√†nh c√¥ng",
      data: timeSlots,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: "C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch khung gi·ªù",
    });
  }
};

const getTimeSlotController = async (req, res) => {
  try {
    const { id } = req.params; // L·∫•y id t·ª´ tham s·ªë URL

    // T√¨m khung gi·ªù theo ID
    const timeSlot = await TimeSlot.findById(id);

    if (!timeSlot) {
      return res.status(404).json({
        success: false,
        message: "Khung gi·ªù kh√¥ng t·ªìn t·∫°i.",
      });
    }

    // Tr·∫£ v·ªÅ k·∫øt qu·∫£ cho client
    res.status(200).json({
      success: true,
      data: timeSlot,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: "L·ªói khi l·∫•y khung gi·ªù.",
    });
  }
};

const createTimeSlotController = async (req, res) => {
  try {
    const { time } = req.body;

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!time) {
      return res
        .status(400)
        .json({ success: false, message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß gi·ªù." });
    }

    // Ki·ªÉm tra xem khung gi·ªù ƒë√£ t·ªìn t·∫°i ch∆∞a
    const existingSlot = await TimeSlot.findOne({ time });
    if (existingSlot) {
      return res
        .status(400)
        .json({ success: false, message: "Khung gi·ªù n√†y ƒë√£ t·ªìn t·∫°i." });
    }

    // T·∫°o khung gi·ªù m·ªõi
    const newTimeSlot = new TimeSlot({ time });
    await newTimeSlot.save();

    res.status(201).json({
      success: true,
      message: "T·∫°o khung gi·ªù th√†nh c√¥ng!",
      data: newTimeSlot,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, message: "L·ªói server!" });
  }
};
const updateTimeSlotController = async (req, res) => {
  try {
    const { id } = req.params; // L·∫•y id t·ª´ tham s·ªë URL
    const updateData = req.body; // L·∫•y d·ªØ li·ªáu c·∫≠p nh·∫≠t t·ª´ body c·ªßa y√™u c·∫ßu

    // Ki·ªÉm tra khung gi·ªù c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng kh√¥ng
    const isBooked = await TimeSlotBooking.exists({ timeSlot: id });
    if (isBooked) {
      return res.status(400).json({
        success: false,
        message: "Kh√¥ng th·ªÉ s·ª≠a khung gi·ªù ƒë√£ c√≥ ƒë·∫∑t s√¢n.",
      });
    }

    // C·∫≠p nh·∫≠t khung gi·ªù theo ID
    const updatedTimeSlot = await TimeSlot.findByIdAndUpdate(id, updateData, {
      new: true,
    });

    if (!updatedTimeSlot) {
      return res.status(404).json({
        success: false,
        message: "Khung gi·ªù kh√¥ng t·ªìn t·∫°i.",
      });
    }

    // Tr·∫£ v·ªÅ k·∫øt qu·∫£ cho client
    res.status(200).json({
      success: true,
      data: updatedTimeSlot,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: "L·ªói khi c·∫≠p nh·∫≠t khung gi·ªù.",
    });
  }
};

const deleteTimeSlotController = async (req, res) => {
  try {
    const { id } = req.params;

    // Ki·ªÉm tra xem khung gi·ªù c√≥ t·ªìn t·∫°i kh√¥ng
    const timeSlot = await TimeSlot.findById(id);
    if (!timeSlot) {
      return res
        .status(404)
        .json({ success: false, message: "Khung gi·ªù kh√¥ng t·ªìn t·∫°i!" });
    }

    // Ki·ªÉm tra xem khung gi·ªù c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng trong TimeSlotBooking kh√¥ng
    const isBooked = await TimeSlotBooking.exists({ timeSlot: id });

    if (isBooked) {
      return res.status(400).json({
        success: false,
        message: "Kh√¥ng th·ªÉ x√≥a khung gi·ªù v√¨ ƒëang c√≥ ng∆∞·ªùi ƒë·∫∑t!",
      });
    }

    // X√≥a khung gi·ªù n·∫øu kh√¥ng c√≥ ai ƒë·∫∑t
    await TimeSlot.findByIdAndDelete(id);

    res
      .status(200)
      .json({ success: true, message: "X√≥a khung gi·ªù th√†nh c√¥ng!" });
  } catch (error) {
    console.error("L·ªói khi x√≥a khung gi·ªù:", error);
    res
      .status(500)
      .json({ success: false, message: "L·ªói server khi x√≥a khung gi·ªù!" });
  }
};

//Tai khoan
// üìå L·∫•y danh s√°ch t·∫•t c·∫£ t√†i kho·∫£n (c√≥ populate th√¥ng tin chi ti·∫øt)
const getAllAccountController = async (req, res) => {
  try {
    // L·∫•y danh s√°ch t·∫•t c·∫£ t√†i kho·∫£n t·ª´ `users`, ·∫©n m·∫≠t kh·∫©u
    const users = await User.find().select("-password");

    // Chia danh s√°ch theo role
    const admins = await Admin.find().select("-password");
    const employees = await Employee.find().select("-password");
    const customers = await Customer.find().select("-password");

    // K·∫øt h·ª£p t·∫•t c·∫£ v√†o m·ªôt danh s√°ch duy nh·∫•t
    const allAccounts = [...admins, ...employees, ...customers];

    res.status(200).json({
      success: true,
      data: allAccounts,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: "L·ªói server",
      error: error.message,
    });
  }
};

// üìå L·∫•y th√¥ng tin m·ªôt t√†i kho·∫£n (c√≥ populate th√¥ng tin chi ti·∫øt)
const getAccountController = async (req, res) => {
  try {
    // T√¨m user theo ID (·∫©n m·∫≠t kh·∫©u)
    const user = await User.findById(req.params.id).select("-password");

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n",
      });
    }

    let userDetails = null;

    // T√¨m th√¥ng tin chi ti·∫øt d·ª±a tr√™n vai tr√≤
    if (user.role === "admin") {
      userDetails = await Admin.findById(req.params.id).select("-password");
    } else if (user.role === "employee") {
      userDetails = await Employee.findById(req.params.id).select("-password");
    } else if (user.role === "customer") {
      userDetails = await Customer.findById(req.params.id).select("-password");
    }

    // N·∫øu kh√¥ng c√≥ th√¥ng tin chi ti·∫øt trong b·∫£ng t∆∞∆°ng ·ª©ng
    if (!userDetails) {
      return res.status(404).json({
        success: false,
        message: `Kh√¥ng t√¨m th·∫•y th√¥ng tin chi ti·∫øt cho ${user.role}`,
      });
    }

    res.status(200).json({
      success: true,
      data: userDetails,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: "L·ªói server",
      error: error.message,
    });
  }
};

const createAccountController = async (req, res) => {
  try {
    const {
      full_name,
      email,
      password,
      phone,
      address,
      role,
      isBlocked,
      hire_date,
    } = req.body;
    if (!role) role = "customer";

    if (!full_name || !email || !password || !phone || !address || !role) {
      return res
        .status(400)
        .json({ success: false, message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin!" });
    }

    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res
        .status(400)
        .json({ success: false, message: "Email ƒë√£ t·ªìn t·∫°i!" });
    }

    // M√£ h√≥a m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(password, 10);

    // T·∫°o user m·ªõi
    const newUser = new User({
      _id: new mongoose.Types.ObjectId(),
      full_name,
      email,
      password: hashedPassword,
      phone,
      address,
      role,
      isBlocked: isBlocked || false,
    });

    let reference;
    if (role === "admin") {
      reference = new Admin({ _id: newUser._id, ...newUser.toObject() });
    } else if (role === "employee") {
      reference = new Employee({
        _id: newUser._id,
        ...newUser.toObject(),
        hire_date: hire_date || Date.now(),
      });
    } else {
      reference = new Customer({ _id: newUser._id, ...newUser.toObject() });
    }

    // L∆∞u d·ªØ li·ªáu
    await newUser.save();
    await reference.save();

    res.status(201).json({
      success: true,
      message: "T·∫°o t√†i kho·∫£n th√†nh c√¥ng!",
      user: newUser,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, message: "L·ªói server", error });
  }
};

const updateAccountController = async (req, res) => {
  try {
    const { id } = req.params;
    const { full_name, email, phone, address, role, isBlocked, hire_date } =
      req.body;
    let { password } = req.body;

    let updateData = { full_name, email, phone, address, isBlocked };

    // Ki·ªÉm tra user c√≥ t·ªìn t·∫°i kh√¥ng
    let existingUser = await User.findById(id);
    if (!existingUser) {
      return res.status(404).json({
        success: false,
        message: "T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i!",
      });
    }

    const oldRole = existingUser.role;

    // N·∫øu c√≥ email m·ªõi, ki·ªÉm tra xem c√≥ b·ªã tr√πng kh√¥ng
    if (email && email !== existingUser.email) {
      const existingEmail = await User.findOne({ email });
      if (existingEmail && existingEmail._id.toString() !== id) {
        return res.status(400).json({
          success: false,
          message: "Email ƒë√£ t·ªìn t·∫°i!",
        });
      }
      updateData.email = email;
    }

    // N·∫øu c√≥ m·∫≠t kh·∫©u m·ªõi, m√£ h√≥a tr∆∞·ªõc khi c·∫≠p nh·∫≠t
    if (password) {
      updateData.password = await bcrypt.hash(password, 10);
    } else {
      updateData.password = existingUser.password;
    }

    // Ki·ªÉm tra xem user c√≥ li√™n k·∫øt v·ªõi h√≥a ƒë∆°n ho·∫∑c l·ªãch ƒë·∫∑t s√¢n kh√¥ng
    const hasLinkedRecords =
      (await Invoice.exists({
        $or: [{ customer: id }, { employee: id }],
      })) || (await TimeSlotBooking.exists({ customer: id }));

    if (oldRole !== role) {
      if (hasLinkedRecords) {
        return res.status(400).json({
          success: false,
          message:
            "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t vai tr√≤ v√¨ t√†i kho·∫£n ƒë√£ t·ªìn t·∫°i trong h√≥a ƒë∆°n ho·∫∑c l·ªãch ƒë·∫∑t s√¢n!",
        });
      }

      // X√≥a vai tr√≤ c≈© tr∆∞·ªõc khi t·∫°o m·ªõi
      await Promise.all([
        oldRole === "employee" && Employee.findByIdAndDelete(id),
        oldRole === "admin" && Admin.findByIdAndDelete(id),
        oldRole === "customer" && Customer.findByIdAndDelete(id),
      ]);

      // ƒê·ª£i x√≥a xong r·ªìi m·ªõi t·∫°o m·ªõi
      const roleModelMap = {
        employee: Employee,
        admin: Admin,
        customer: Customer,
      };

      if (!roleModelMap[role]) {
        return res.status(400).json({
          success: false,
          message: "Vai tr√≤ kh√¥ng h·ª£p l·ªá!",
        });
      }

      const newRoleData = {
        _id: id,
        ...updateData,
        ...(role === "employee" && { hire_date: hire_date || Date.now() }),
      };

      await roleModelMap[role].create(newRoleData);
    } else {
      // N·∫øu role kh√¥ng ƒë·ªïi, c·∫≠p nh·∫≠t d·ªØ li·ªáu theo b·∫£ng t∆∞∆°ng ·ª©ng
      const roleModelMap = {
        admin: Admin,
        employee: Employee,
        customer: Customer,
      };

      if (!roleModelMap[role]) {
        return res.status(400).json({
          success: false,
          message: "Vai tr√≤ kh√¥ng h·ª£p l·ªá!",
        });
      }

      const updatedData =
        role === "employee"
          ? { ...updateData, hire_date: hire_date || existingUser.hire_date }
          : updateData;

      await roleModelMap[role].findByIdAndUpdate(id, updatedData, {
        new: true,
      });
    }

    // C·∫≠p nh·∫≠t th√¥ng tin trong b·∫£ng User
    await User.findByIdAndUpdate(id, { ...updateData, role }, { new: true });

    res.status(200).json({
      success: true,
      message: "C·∫≠p nh·∫≠t t√†i kho·∫£n th√†nh c√¥ng!",
    });
  } catch (error) {
    console.error(error); // Log l·ªói chi ti·∫øt
    res.status(500).json({
      success: false,
      message: "L·ªói server",
      error: error.message,
    });
  }
};

const deleteAccountController = async (req, res) => {
  try {
    const { id } = req.params;

    // Ki·ªÉm tra xem t√†i kho·∫£n c√≥ t·ªìn t·∫°i kh√¥ng trong t·∫•t c·∫£ b·∫£ng
    let existingUser = await User.findById(id);

    if (!existingUser) {
      return res.status(404).json({
        success: false,
        message: "T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i!",
      });
    }

    const role = existingUser.role;

    // Ki·ªÉm tra xem t√†i kho·∫£n c√≥ trong TimeSlotBooking ho·∫∑c Invoice kh√¥ng
    const isInTimeSlotBooking = await TimeSlotBooking.exists({ user: id });
    const isInInvoice = await Invoice.exists({
      $or: [{ customer: id }, { employee: id }],
    });

    if (isInTimeSlotBooking || isInInvoice) {
      return res.status(400).json({
        success: false,
        message: "Kh√¥ng th·ªÉ x√≥a t√†i kho·∫£n v√¨ ƒë√£ c√≥ l·ªãch ƒë·∫∑t s√¢n ho·∫∑c h√≥a ƒë∆°n!",
      });
    }

    // X√≥a t√†i kho·∫£n t·ª´ b·∫£ng t∆∞∆°ng ·ª©ng v·ªõi role
    if (role === "admin") {
      await Admin.findByIdAndDelete(id);
    } else if (role === "employee") {
      await Employee.findByIdAndDelete(id);
    } else if (role === "customer") {
      await Customer.findByIdAndDelete(id);
    }

    // X√≥a t√†i kho·∫£n trong b·∫£ng users
    await User.findByIdAndDelete(id);

    res.status(200).json({
      success: true,
      message: "X√≥a t√†i kho·∫£n th√†nh c√¥ng!",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "L·ªói server",
      error: error.message,
    });
  }
};

//L·∫•y kh√°ch h√†ng
//Tai khoan
// üìå L·∫•y danh s√°ch t·∫•t c·∫£ t√†i kho·∫£n (c√≥ populate th√¥ng tin chi ti·∫øt)
const getAllCustomerController = async (req, res) => {
  try {
    const customers = await Customer.find().select("-password");

    res.status(200).json({
      success: true,
      data: customers,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: "L·ªói server",
      error: error.message,
    });
  }
};

const getCustomerController = async (req, res) => {
  try {
    // T√¨m kh√°ch h√†ng theo ID (·∫©n m·∫≠t kh·∫©u)
    const customer = await Customer.findById(req.params.id).select("-password");

    // Ki·ªÉm tra n·∫øu kh√¥ng t√¨m th·∫•y kh√°ch h√†ng
    if (!customer) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng",
      });
    }

    res.status(200).json({
      success: true,
      data: customer,
    });
  } catch (error) {
    console.error("L·ªói khi l·∫•y th√¥ng tin kh√°ch h√†ng:", error);
    res.status(500).json({
      success: false,
      message: "L·ªói server",
      error: error.message,
    });
  }
};

const updateReputationController = async (req, res) => {
  try {
    const { id } = req.params; // L·∫•y ID kh√°ch h√†ng t·ª´ URL
    const { reputation_score } = req.body; // L·∫•y ƒëi·ªÉm uy t√≠n t·ª´ request body

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (reputation_score === undefined || isNaN(reputation_score)) {
      return res.status(400).json({
        success: false,
        message: "ƒêi·ªÉm uy t√≠n kh√¥ng h·ª£p l·ªá.",
      });
    }

    // T√¨m kh√°ch h√†ng theo ID
    const customer = await Customer.findById(id);
    if (!customer) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng.",
      });
    }

    // C·∫≠p nh·∫≠t ƒëi·ªÉm uy t√≠n (ƒë·∫£m b·∫£o kh√¥ng nh·ªè h∆°n 0)
    customer.reputation_score = Math.max(0, reputation_score);
    await customer.save();

    res.status(200).json({
      success: true,
      message: "C·∫≠p nh·∫≠t ƒëi·ªÉm uy t√≠n th√†nh c√¥ng.",
      data: customer,
    });
  } catch (error) {
    console.error("‚ùå L·ªói khi c·∫≠p nh·∫≠t ƒëi·ªÉm uy t√≠n:", error);
    res.status(500).json({
      success: false,
      message: "L·ªói server.",
      error: error.message,
    });
  }
};

//L·∫•y t·ªïng doanh thu
const getRevenueController = async (req, res) => {
  try {
    const { type, startDate, endDate } = req.query;

    // Chuy·ªÉn ƒë·ªïi ng√†y t·ª´ string sang object Date
    const start = new Date(startDate);
    const end = new Date(endDate);
    end.setHours(23, 59, 59, 999);

    let groupBy = {};
    if (type === "day") {
      groupBy = {
        year: { $year: "$createdAt" },
        month: { $month: "$createdAt" },
        day: { $dayOfMonth: "$createdAt" },
      };
    } else if (type === "month") {
      groupBy = {
        year: { $year: "$createdAt" },
        month: { $month: "$createdAt" },
      };
    } else if (type === "year") {
      groupBy = { year: { $year: "$createdAt" } };
    } else {
      return res.status(400).json({ message: "Lo·∫°i th·ªëng k√™ kh√¥ng h·ª£p l·ªá" });
    }

    // Truy v·∫•n h√≥a ƒë∆°n ƒë·ªÉ t√≠nh t·ªïng doanh thu
    const revenueData = await Invoice.aggregate([
      { $match: { createdAt: { $gte: start, $lte: end } } },
      {
        $group: {
          _id: groupBy,
          totalRevenue: { $sum: "$totalAmount" }, // T·ªïng doanh thu
        },
      },
      { $sort: { "_id.year": 1, "_id.month": 1, "_id.day": 1 } },
    ]);

    res.json({ revenueData });
  } catch (error) {
    console.error("L·ªói khi l·∫•y th·ªëng k√™:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

module.exports = {
  getAllUsersController,
  getAllTimeSlotController,
  getTimeSlotController,
  createTimeSlotController,
  updateTimeSlotController,
  deleteTimeSlotController,
  getAllAccountController,
  getAccountController,
  createAccountController,
  updateAccountController,
  deleteAccountController,
  getAllCustomerController,
  getCustomerController,
  updateReputationController,
  getRevenueController,
};
